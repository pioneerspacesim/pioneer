<html>
	<head>
		<title>Pioneer technical info<title>
	<style type="text/css">
	h1 { font-size: 20pt; }
	h2 { font-size: 18pt; }
	h3 { font-size: 16pt; }
	h4 { font-size: 14pt; }
	h5 { font-size: 12pt; }
	dt { font-style: italic; }
	pre { background: #ddd; }
	</style>
	</head>
<body>
	
<h1>Pioneer technical info</h1>
<h2>Index</h2>
<ul>
	<li><a href="#sbre-models">Making 3d models</a></li>
	<ul>
		<li><a href="#models-def-example">models.lua example</a>
		<li><a href="#sbre-funcs-quickref">Function quick reference</a>
		<li><a href="#sbre-function-reference">Complete function reference</a>
		<li><a href="#sbre-model-conventions">Model conventions</a>
	</ul>
	<li><a href="#height-map-format">Terrain height map format</a></li>
</ul>

<a name="sbre-models"><h3>Making 3d models</h3></a>
<p>Models are defined in models.lua (read src/LmrModel.cpp).
<a name="models-def-example"><h4>models.lua example</h4></a>
<p>A simple example model:
<pre>
	function cargo_info()
		return {
			lod_pixels = {20, 50, 0},
			bounding_radius = 1.5,
			materials = {'body', 'text'}
		}
	end
8	function cargo_static(lod)
9		local divs = 8*lod
10		set_material('body', .5,.5,.5,1, 0,0,0, 0, 0,0,0)
11		set_material('text', 1,0,0,1, 0,0,0, 0, 0,0,0)
12		local top = v(0,1,0)
13		local bottom = v(0,-1,0)
14		use_material('body')
15		cylinder(divs, top, bottom, v(1,0,0), 1.0)
	end
17	function cargo_dynamic(lod)
18		if lod == 3 then
19			local textpos = v(0,1,0)
20			use_material('text')
21			zbias(1, textpos, v(0,1,0))
22			text(get_arg_string(0), textpos, v(1,0,0), v(0,1,0), 0.1)
		end
	end
</pre>

<p>Explanation:</p>
function modelname_info() returns the on-screen pixels sizes of various Level of Detail
(LOD) levels (lod_pixels). Here it is &lt; 20px for lod 1, &lt; 50px for lod 2 and all
larger sizes lod 3. bounding_radius must encompass the whole model from
position (0,0,0). All materials used by a model must be declared here also.
<p>
function modelname_static(lod) defines the static geometry of a model, ie the
shit that doesn't change from frame to frame. It may still use materials that
are altered per-frame by modelname_dynamic(lod). Both functions have 1
argument: the lod level (starting from 1 for lowest detail level).
<p>
The rest is truly self-explanatory.

<a name="sbre-funcs-quickref"><h4>Function quick reference</h4></a>
Square brackets indicate optional arguments.
<pre>
bezier_3x3(integer divs_u, integer divs_v, v1, v2, v3,
                                           v4, v5, v6,
                                           v7, v8, v9)
bezier_4x4(integer divs_u, integer divs_v, v1, v2, v3, v4,
                                           v5, v6, v7, v8,
                                           v9, v10, v11, v12,
                                           v13, v14, v15, v16)
call_model(string modelname, vector pos, vector xaxis, vector yaxis, float scale)
circle(integer steps, vector center, vector normal, vector up, float radius)
cylinder(integer steps, vector start, vector end, vector up, float radius)
extrusion(vector start, vector end, vector up, float radius, v1, v2, v3, ...)
flat(integer divs, vector normal, { v_line },
                 { v_quadric1, v_quadric2 },
                 { v_cubic1, v_cubic2, v_cubic3 },
                 etc )
geomflag(integer)
get_arg(integer)
get_arg_material(integer)
get_arg_string(integer)
material(dr, dg, db, alpha, sr, sg, sb, shininess, er, eg, eb)
noise(x, y, z) or noise(vector)
quad(vector v1, vector v2, vector v3, vector v4)
ring(integer steps, vector start, vector end, vector updir, float radius)
set_material(string material_name, dr, dg, db, alpha, sr, sg, sb, shiny, er, eg, eb)
triangle(vector v1, vector v2, vector v3)
tube(integer steps, vector start, vector end, vector up, float inner_radius, float outer_radius)
text("some string", vector pos, vector norm, vector textdir, float scale [,{center=true/false}])
thruster(vector pos, vector direction, float size, bool linear_only)
use_material(string material_name)
xref_bezier_3x3( {as bezier_3x3()} )
xref_bezier_4x4( {as bezier_4x4()} )
xref_circle(integer circumference_steps, vector center, vector normal, vector up, float radius)
xref_cylinder(integer steps, vector start, vector end, vector up, float radius)
xref_flat( {as flat()} )
xref_quad(vector v1, vector v2, vector v3, vector v4)
xref_ring(integer steps, vector start, vector end, vector updir, float radius)
xref_thruster(vector pos, vector direction, float size, bool linear_only)
xref_triangle(vector v1, vector v2, vector v3)
xref_tube(integer steps, vector start, vector end, vector up, float inner_radius, float outer_radius)
zbias(integer amount, vector position, vector normal)
zbias(0)
</pre>

<a name="sbre-function-reference"><h4>Complete function reference</h4></a>
<pre>
XXX this crap needs updating for Lua shit
<!--
material(dr, dg, db, sr, sg, sb, shininess, er, eg, eb)
  diffuse rgb, specular rgb, shininess, emissive rgb
material(0-3)
  set material from params->pColor[4]
material(animfn=xxx,
	material(dr,dg,db,sr,sg,sb,shininess, er,eg,eb),
	material(dr,dg,db,sr,sg,sb,shininess, er,eg,eb))
  animate material between first and second using anim function

triangle(vector v1, vector v2, vector v3)

quad(vector v1, vector v2, vector v3, vector v4)

circle(circumference_steps, vector center, vector normal, vector up, radius=float radius)
  eg: circle(8, some_vector, v(0,0,1), v(0,1,0), radius=10.0)

  vector up - points from the centre of the circle to the circumference, in
              any direction
  circumference_steps - can either be an integer, or an objlod identifier to
  specify steps on a per-lod basis

cylinder(steps, vector start, vector end, vector up, radius=float radius)
  eg: cylinder(8, v(15,10,0), v(15,20,0), v(0,0,1), radius=10.0)

tube(steps, vector start, vector end, vector up, innerrad=float, outerrad=float)
  eg: tube(8, poohat1, poohat2, v(0,0,1), innerrad=5.0, outerrad=10.0)

extrusion(vector start, vector end, vector up, radius=float, {v1, v2, v3, ... })
  eg: extrusion(v(0,0,-10), v(0,0,0), v(0,1,0), radius=1.0, {v(10,10,0), v(15,0,0), v(10,-10,0), v(-10,-10,0), v(-10,10,0)})

  v1,v2,v3,... describes the 2d shape to be extruded into 3d along start->end.
  it should be wound counter-clockwise in x,y, with the z coordinate ignored
  up is a normal, and should be perpendicular to end-start
-->
geomflag(int)
  set an integer flag on subsequent geometry, that can be used by the pioneer
  collision detector to determine what bits of a model has been struck.
	
  Pioneer uses these flag values:
	For starports:
	0x10 indicates starport
	0x10 - 1st docking bay hit surface
	0x11 - 2nd docking bay hit surface
	0x12 - 3rd docking bay hit surface
	0x13 - 4th docking bay hit surface
	0x8000 - 1st docking bay stage1 position and orientation
	0x8001 - 2nd docking bay " "
	0x8002 - 3rd docking bay " "
	0x8003 - 4th docking bay " "
	0x8010 - 1st docking bay stage2 position and orientation (optional)
	0x8011 - 2nd docking bay " "
	0x8012 - 3rd docking bay " "
	0x8013 - 4th docking bay " "
	0x8020 - 1st docking bay stage3 (ship dock) position and orientation (optional)
	0x8021 - 2nd docking bay " "
	0x8022 - 3rd docking bay " "
	0x8023 - 4th docking bay " "
	stage1,stage2 orientations should point out of docking bay (launching
orientation)
	Docking bay positions and orientations should be done like so:
	geoflag(0x8000)
	invisible:tri(position, v(0,0,0), v(0,0,0))
	invisible:tri(v(0,0,0), xaxis, yaxis)

<!--
text("some literal string", vector pos, vector norm, vector xaxis, [xoff=, yoff=, scale=, onflag=])
text(params:textnum, vector pos, vector norm, vector xaxis, [xoff=, yoff=, scale=, onflag=])
  draws text from either the string literal provided or the params strings (passed at render time in ObjParams)
  * the optional onflag= means the thing is only drawn if the model parameters
  * flag specified is non-zero (flags can be specified by number or by animfn,
  * which will indicates to use the flag of the same index as the given anim func's
  * underlying anim src. Eg: animfn=2, animfn=stationopen

subobject(object_name, vector pos, vector up, vector zaxis [, scale=float, onflag=])
  eg:subobject(hermite_wank, v(0,0,0), v(0,1,0), v(0,0,1), scale=1.0)
  * onflag= functions as described above

thruster(direction, vector position, float size)
  eg: xref:notangular:thruster(fwd, v(10,0,0), 30.0)

  notangular flag indicates that this thruster should not be used to display
  angular acceleration.
  'direction' is fwd, rev, up, down, left, right
-->
</pre>
	
<a name="sbre-model-conventions"><h4>Model conventions</h4></a>

<p>All polygons must be wound counter-clockwise.</p>

<h5>General</h5>
Geometry with geomflag &gt;= 0x8000 is not passed to the collision detector.

<h5>Space stations</h5>
<ul>
	<li>Objects which sit in a rotating frame (ie orbital starports) rotate in
	the Y axis.
	<li>Docking procedure is: XXX read SpaceStation.cpp::DoDockingAnimation() and SpaceStation::Render()
	<ol>
	</ol>
</ul>


<a name="height-map-format"><h3>Terrain height map format</h3></a>
Height maps (data/*.hmap) have the format:
<pre>
<em>Uint16</em> map width
<em>Uint16</em> map height
<em>Sint16[width*height]</em> elements (with elevation in meters)
</pre>
</body>
